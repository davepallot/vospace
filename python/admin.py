#!/usr/bin/python -u
# 2010/03/30
# v0.1
#
# admin.py
# Python code to handle VOSpace operations

import copy
from config import *
from datetime import datetime
import os
import re
import shutil
import sys
from threading import *
from time import sleep
import uuid
from resources import *

try:
  from lxml import etree
except ImportError:
  try:
    # Python 2.5
    import xml.etree.cElementTree as etree
  except ImportError:
    try:
      # Python 2.5
      import xml.etree.ElementTree as etree
    except ImportError:
      try:
        # normal cElementTree install
        import cElementTree as etree
      except ImportError:
        try:
          # normal ElementTree install
          import elementtree.ElementTree as etree
        except ImportError:
          print("Failed to import ElementTree from any known place")


def check_uri(uri, sm, shouldExist = True, ignoreExist = False):
  """
  Check whether the specified URI is:
  - syntactically valid
  - is free (or a Container)
  - designates a node with a valid parent (Container)
  """
  checks = {'exists': False, 'container': False}
  uriRegex = """vos://[\w\d][\w\d\-_\.!~\*'\(\)\+=]{2,}(![\w\d\-_\.!~\*'\(\)\+=]+(/[\w\d\-_\.!~\*'\(\)\+=]+)*)+"""
  if re.match(uriRegex, uri) == None:
    raise VOSpaceError(400, "The requested URI is invalid.", summary = INVALID_URI)
  if uri.endswith(AUTO) or uri.endswith(NULL): 
    if uri[-(len(AUTO) + 1)] != '/' and uri(-(len(NULL) + 1)) != '/':
      raise VOSpaceError(400, "The requested URI is invalid.", summary = INVALID_URI)
    return checks
  exists = sm.already_exists('nodes', uri)
  if exists:
    checks['exists'] = True
    if sm.get_node_type(uri)[0]['type'] == CONTAINER_NODE: checks['container'] = True
    if not(shouldExist) and not(ignoreExist): 
      if not(checks['container']): raise VOSpaceError(409, "A Node already exists with the requested URI.", summary = DUPLICATE_NODE)
  else:
    if shouldExist and not(ignoreExist): raise VOSpaceError(409, "A Node does not exist with the requested URI: %s" % uri, summary = NODE_NOT_FOUND)
  parent = uri[:uri.rfind("/")]
  if parent != ROOT_NODE and sm.get_node_type(parent)[0]['type'] != CONTAINER_NODE:
    raise VOSpaceError(500, "The parent node is not valid.", summary = INVALID_URI)
  return checks

def generate_uri(uri):
  """
  Get an autogenerated URI
  """
  return uri[:-5] + uuid.uuid4().hex

def get_location(identifier):
  """
  Get a valid location for the data (bytes)
  """
  return STORAGE_LOCATION + "/" + identifier[len(ROOT_NODE) + 1:]


class NodeManager():
  """
  Class to manage node operations within VOSpace
  """

  def __init__(self, sm):
    self.sm = sm
    self.nf = NodeFactory()

  def create_node(self, xmlnode):
    """ 
    Create a node in the space with the specified parameters.
    """
    node = self.nf.get_node(xmlnode)
    # Check that the uri is valid
    check_uri(node.uri, self.sm, shouldExist = False)
    # Check for reserved URI
    if node.uri.endswith(AUTO): 
      node.set_uri(generate_uri(node.uri))
    # Make sure capabilities is clear
    node.clear_capabilities()
    if isinstance(node, DataNode):
      # Add service views
      node.clear_accepts()
      for uris in SERVICE_VIEWS:
        node.add_accepts(uris)
    # Make sure provides is clear
      node.clear_provides()
      views = [set(PROVIDES_VIEWS[x]) for x in SERVICE_VIEWS]
      views = set.union(*views)
      for view in list(views):
        node.add_provides(view)
    # Make sure nodes is clear
    if isinstance(node, ContainerNode):
      node.clear_nodes()
    # Check properties
    for property in node.properties:
      if property in READ_ONLY_PROPERTIES: raise VOSpaceError(401, 'User does not have permissions to set a readonly property.', summary = PERMISSION_DENIED)
    # If container, create container
    location = get_location(node.uri)
    if isinstance(node, ContainerNode) and not os.path.exists(location): os.makedirs(location)
    # Store node
    self.sm.create_node(node.tostring(), node.uri, NODETYPES[node.TYPE], location = location) 
    # Register properties
    self.sm.register_properties(node.uri, node.properties)
    return xmlnode

  def update_node(self, uri, xmlnode):
    """
    Update the specified node with the specified details.
    """
    oldnode = self.sm.get_node(uri)
    if len(oldnode) == 0: raise VOSpaceError(404, 'A Node does not exist with the requested URI.')
    oldnode = self.nf.get_node(oldnode[0]['node'])
    newnode = self.nf.get_node(xmlnode)
    # Check properties
    for property in newnode.properties:
      if property in READ_ONLY_PROPERTIES: raise VOSpaceError(401, 'User does not have permissions to set a readonly property.', summary = PERMISSION_DENIED)
      if property in oldnode.properties: 
        oldnode.properties[property] = newnode.properties[property]
      else:
        oldnode.add_property(property, newnode.properties[property])
    # Delete properties if applicable
    props = xmlnode.xpath('//vos:property[@xsi:nil = "true"]', namespaces = {'vos': VOSPACE_NS, 'xsi': XSI_NS})
    for prop in props:
      del oldnode.properties[prop.get('uri')]
    # Store update
    self.sm.update_node(oldnode.uri, oldnode.uri, oldnode.tostring())
    return oldnode.tostring()

  def delete_node(self, uri):
    """
    Delete the node from the space with the specified uri.
    Should this just set a flag in the db? Should the bytes be deleted?
    """
    if self.sm.already_exists('nodes', uri):
      self.sm.delete_node(uri)
    else:
      raise VOSpaceError(404, "The specified node does not exist.")


class Future():
  def __init__(self, func, name, *param):
    # constructor
    self.__done = 0
    self.__result = None
    self.__status = 'Working'
    self.__excpt = None
    self.name = name

    self.__C = Condition()

    self.__T = Thread(target = self.Wrapper, args = (func, param))
    self.__T.setName("FutureThread")
    self.__T.start()

  def __repr__(self):
    return '<Future (%s) at ' % self.name + hex(id(self)) + ':' + self.__status + '>'

  def __call__(self):
    self.__C.acquire()
    while self.__done == 0:
      self.__C.wait()
    self.__C.release()
    if self.__excpt: 
      raise self.__excpt[0], self.__excpt[1], self.__excpt[2]
    result = copy.deepcopy(self.__result)
    return result

  def isDone(self):
    return self.__done

  def Wrapper(self, func, param):
    self.__C.acquire()
    try: 
      self.__result = func(*param)
    except:
      self.__result = "Exception raised within Future"
      self.__excpt = sys.exc_info()
    self.__done = 1
    self.__status = `self.__result`
    self.__C.notify()
    self.__C.release()


class JobManager():
  """
  Class to manage UWS jobs
  """
  
  def __init__(self, sm):
    self.sm = sm
    self.threads = []
    self.handlers = {}

  def add_job(self, jobInfo, resultId, method, run = False):
    """
    Add a job to the queue
    """
    job = Job()
    job.set_job_info(jobInfo)
    jobid = self._get_job_id()
    job.set_job_id(jobid)
    if run:
      job.set_phase('QUEUED')
    else:
      job.set_phase('PENDING')
    self.sm.register_job(job.tostring(), job.jobId, phase = job.phase, resultid = resultId, method = method)
    if run:
      self._launch_job(job)
    return jobid

  def check_jobs(self):
    """
    Check for new/aborted jobs and completed jobs in the queue
    """
    # New/aborted jobs
    try:
      jobs = self.sm.get_job('%', phase = 'QUEUED')
      for job in jobs:
        self._launch_job(Job(job['job']))
      res = self.sm.get_aborted_jobs()
      aborts = [x['identifier'] for x in res]
      # Completed jobs
      for t in self.threads:
        if t.isDone() or t.name in aborts:
          self.threads.remove(t)
           # Set job status to COMPLETED
          job = Job(self.sm.get_job(t.name)[0]['job'])
          if t._Future__excpt == None:
            job.set_phase('COMPLETED')
            if t._Future__result != None:
              job.set_results(t._Future__result)  
            status = True
          else:
            job.set_phase('ERROR')
            job.set_error_summary(str(t._Future__excpt[1]).replace("'", ""))
            status = False
          job.set_end_time(datetime.utcnow().isoformat())
          self.sm.update_job(job = job, completed = status)
    except Exception, e:
      print "Error:", e

  def _get_job_id(self):
    """
    Get a globally unique identifier
    """
    return uuid.uuid4().hex

  def _launch_job(self, job):
    """
    Launch the specified job consisting of the specified method and arguments
    """
    details = self.sm.get_job_details(job.jobId)
    handler = self.handlers[details[0]['method']]
    type = details[0]['type']
    resultId = details[0]['resultid']
    job.set_phase('EXECUTING')
    job.set_start_time(datetime.utcnow().isoformat())
    job.add_result(resultId, 'http://localhost:8000/%s/%s/results/details' % (type, job.jobId))
    self.sm.update_job(job = job)
    self.threads.append(Future(handler, job.jobId, job))

  def register_handler(self, method, handler):
    """
    Register the specified handler for the specified method
    """
    self.handlers[method] = handler

  def get_jobs(self, type = None):
    """
    Get the list of extant jobs
    """
    joblist = JobList()
    for jobs in self.sm.get_jobs(type = type):
      joblist.add_job(jobs['identifier'], jobs['phase'])
    return joblist.tostring()


class TransferManager():
  """
  Class to manage transfers within VOSpace
  """

  def __init__(self, sm, nm, jm):
    self.sm = sm
    self.nm = nm
    self.jm = jm
    self.nf = NodeFactory()
    self._register_handlers()

  def _register_handlers(self):
    """
    Register the handlers for the particular methods
    """
    self.jm.register_handler("move_node", self.move_node)
    self.jm.register_handler("copy_node", self.copy_node)
    self.jm.register_handler("push_to_vospace", self.push_to_vospace)
    self.jm.register_handler("push_from_vospace", self.push_from_vospace)
    self.jm.register_handler("pull_to_vospace", self.pull_to_vospace)
    self.jm.register_handler("pull_from_vospace", self.pull_from_vospace)
    
  def add_transfer(self, transfer, run):
    """
    Add a transfer job to the queue
    """
    transfer = Transfer(transfer)
    target = transfer.target
    external = not(transfer.direction.startswith('vos'))
    # External data transfers
    if external:
      # Check transfer uri
      checks = check_uri(transfer.target, self.sm, ignoreExist = True)
      if checks['container']: raise VOSpaceError(500, "Data cannot be uploaded to a container")
      if not checks['exists']:
        if transfer.direction in ['pushToVoSpace', 'pullToVoSpace']:
          node = DataNode()
          # Reserved URI
          if transfer.target.endswith(AUTO):
            uri = generate_uri(transfer.target)
            transfer.target = uri
          else:
            uri = transfer.target
          node.set_uri(uri)
          location = get_location(uri)
          self.sm.create_node(node.tostring(), uri, NODETYPES[node.TYPE], location = location)
        else:
          raise VOSpaceError(409, "A Node does not exist with the requested URI.", summary = NODE_NOT_FOUND)
      # Verify view
      print transfer.view.uri
      if transfer.view.uri != DEFAULT_VIEW and transfer.view.uri not in SERVICE_VIEWS and ANY_VIEW not in SERVICE_VIEWS: raise VOSpaceError(500, "Service does not support the requested View", summary = VIEW_NOT_SUPPORTED)
      # Negotiate protocols
      transfer.set_protocols(self._negotiate_protocols(transfer.protocols, transfer.direction))
    # Accept job
    method = self._get_handler(transfer)
    jobid = self.jm.add_job(transfer.tostring(), 'transferDetails', method, run)
    if external:
      for protocol in transfer.protocols:
        self.sm.register_transfer(jobid, protocol.endpoint)
      self.sm.register_details(jobid, transfer.tostring())
    return jobid

  def _negotiate_protocols(self, protocols, direction):
    """
    Negotiate the appropriate protocols
    """
    uris = [p.uri for p in protocols]
    if direction in ['pushFromVoSpace', 'pullToVoSpace']:
      supported = list(set(uris) & set(CLIENT_PROTOCOLS))
    else:
      supported = list(set(uris) & set(SERVER_PROTOCOLS))
    if len(supported) == 0: raise VOSpaceError(500, "The service supports none of the requested Protocols", summary = PROTOCOL_NOT_SUPPORTED)
    selected = [p for p in protocols if p.uri in supported]
    if direction in ['pullFromVoSpace', 'pushToVoSpace']:
      for protocol in selected:
        protocol.set_endpoint(SERVER_PROTOCOLS[protocol.uri].get_endpoint())
    return selected

  def _get_handler(self, transfer):
    """
    Return the operational details of the transfer
    """
    if transfer.direction == 'pushToVoSpace':
      method = "push_to_vospace"
    elif transfer.direction == 'pullToVoSpace':
      method = "pull_to_vospace"
    elif transfer.direction == 'pullFromVoSpace':
      method = "pull_from_vospace"
    elif transfer.direction == 'pushFromVoSpace':
      method = "push_from_vospace"
    elif not(transfer.keepBytes):
      method = "move_node"
    elif transfer.keepBytes:
      method = "copy_node"
    else:
      raise VOSpaceError(500, "One of the specified parameters is invalid.")
    return method

  def move_node(self, job):
    """
    Move from the specified target to the direction
    """
    transfer = Transfer(job.jobInfo)
    target = transfer.target
    direction = transfer.direction
    result = None
    # Check uris
    check_uri(target, self.sm, shouldExist = True)
    checks = check_uri(direction, self.sm, shouldExist = False)
    null = direction.endswith(NULL)
    # Retrieve existing record
    node = self.sm.get_node(target)[0]['node']
    node = self.nf.get_node(node)
    # Check whether endpoint is reserved URI
    if null: self.nm.delete_node(target)
    if direction.endswith(AUTO): 
      direction = generate_uri(direction)
      result = {'destination': direction}
    if not(null):
      # Check if endpoint is a container
      if checks['exists'] and checks['container']: direction += target[target.rfind('/'):]
      # Change identifier
      node.set_uri(direction)
      # Update db
      self.sm.update_node(target, direction, node.tostring())
    # Check if target is a container
    if isinstance(node, ContainerNode):
      # Move children
      for child in self.sm.get_children(target):
        node = self.nf.get_node(self.sm.get_node(child)[0]['node'])
        if null:
          self.nm.delete_node(node.uri)
        else:
          new_uri = node.uri.replace(target, direction)
          node.set_uri(new_uri)
          self.sm.update_node(child, new_uri, node.tostring())
    return result

  def copy_node(self, job):
    """
    Copy from the specified target to the direction
    """
    transfer = Transfer(job.jobInfo)
    target = transfer.target
    direction = transfer.direction
    result = None
    # Check uris
    check_uri(target, self.sm, shouldExist = True)
    checks = check_uri(direction, self.sm, shouldExist = False)
    # Retrieve existing record
    node = self.sm.get_node(target)[0]['node']
    node = self.nf.get_node(node)
    # Check whether endpoint is reserved URI
    if direction.endswith(AUTO): 
      direction = generate_uri(direction)
      result = {'destination': direction}
    # Check if endpoint is a container
    if checks['exists'] and checks['container']: direction += target[target.rfind('/'):]
    # Copy it
    old_location = self.sm.get_location(target)[0]['location']
    new_location = self._create_copy(node, direction)
    # Check if target is a container
    if isinstance(node, ContainerNode):
      # Copy children
      for child in self.sm.get_all_children(target):
        child_node = self.nf.get_node(self.sm.get_node(child)[0]['node'])
        new_uri = child_node.uri.replace(target, direction)
        self._create_copy(child_node, new_uri)
    # Copy bytes    
    if isinstance(node, ContainerNode):
      shutil.copytree(old_location, new_location)
    else:
      shutil.copy(old_location, new_location)
    return result
    
  def _create_copy(self, node, direction):
    """
    Create a copy of the specified node
    """
    new_node = copy.copy(node)
    new_node.set_uri(direction)
    new_location = get_location(direction)
    # Insert into db  
    self.sm.create_node(new_node.tostring(), direction, NODETYPES[node.TYPE], location = new_location)
    return new_location

  def push_to_vospace(self, job):
    """
    Transfer data to the service (client mediated)
    """
    transfer = Transfer(job.jobInfo)
    # Loop checking for upload until 1 hour has passed
    starttime = datetime.now()
    location = self.sm.get_location(transfer.target)[0]['location']
    original = os.path.exists(location) and datetime.fromtimestamp(os.stat(location).st_mtime) or None
    while (datetime.now() - starttime).seconds / 3600 == 0:
      if os.path.exists(location):
        statinfo = os.stat(location)
        last_modified = datetime.fromtimestamp(statinfo.st_mtime)
        if last_modified != original and (datetime.now() - last_modified).seconds > 5: break
      sleep(1)    
    # Log transfer as completed
    self.sm.complete_transfers(job.jobId) 
    return None

  def pull_to_vospace(self, job):
    """
    Transfer data to the service (server mediated)
    """
    transfer = Transfer(job.jobInfo)
    # Loop through protocols trying to load data
    location = self.sm.get_location(transfer.target)[0]['location']
    for protocol in transfer.protocols:
      try:
        if CLIENT_PROTOCOLS[protocol.uri].load_data(protocol.endpoint, location): 
          break
      except Exception, e:
        if "Couldn't resolve host" in e[1]:
          raise VOSpaceError(500, "Destination URI is invalid", INVALID_URI)
        else:
          raise VOSpaceError(500, e[1])
    # Log transfer as completed
    self.sm.complete_transfers(job.jobId) 
    return None

  def push_from_vospace(self, job):
    """
    Transfer data from the service (server mediated)
    """
    transfer = Transfer(job.jobInfo)
    # Loop through protocols trying to load data
    location = self.sm.get_location(transfer.target)[0]['location']
    for protocol in transfer.protocols:
      try:
        if SERVER_PROTOCOLS[protocol.uri].send_data(protocol.endpoint, location): 
          break
      except Exception, e:
        print e
        if "Couldn't resolve host" in e[1]:
          raise VOSpaceError(500, "Destination URI is invalid", INVALID_URI)
        else:
          raise VOSpaceError(500, e[1])
    # Log transfer as completed
    self.sm.complete_transfers(job.jobId) 
    return None

  def pull_from_vospace(self, job):
    """
    Transfer data from the service (client mediated)
    """
    transfer = Transfer(job.jobInfo)
    # Loop checking for download until 1 hour has passed
    starttime = datetime.now()
    while (datetime.now() - starttime).seconds / 3600 == 0:
      status = self.sm.get_transfer_completed(job.jobId)
      complete = len([x for x in status if x['completed'] is not None])
      if complete == len(status): break
      sleep(1)    
    # Log transfer as completed
    self.sm.complete_transfers(job.jobId) 
    return None


