#!/Users/mjg/anaconda/bin/python
"""A DataLab client
"""

import sys
from sys import platform
import os
import logging
import shutil
import ConfigParser
from subprocess import Popen, PIPE
from time import gmtime, strftime
from httplib2 import Http
from urlparse import urlparse

import myvos as vos
import myfuse
from myfuse import FUSE
from __version__ import version
from myvofs import VOFS
DAEMON_TIMEOUT = 60


class Option:
  def __init__(self, name, value, description, default = None, required = False):
    self.name = name
    self.value = value
    self.description = description
    self.default = default
    self.required = required


class DataLab:
  def __init__(self):
    self.home = '%s/.datalab' % os.path.expanduser('~')
    # Check that $HOME/.datalab exists 
    if not os.path.exists(self.home):
      os.makedirs(self.home)
    # See if datalab conf file exists
    self.config = ConfigParser.RawConfigParser(allow_no_value = True)
    if not os.path.exists('%s/dl.conf' % self.home):
      self.config.add_section('datalab')
      self.config.set('datalab', 'created', strftime('%Y-%m-%d %H:%M:%S', gmtime()))
      self._write()
    else:
      self.config.read('%s/dl.conf' % self.home)
      
  def save(self, section, param, value):
    if not self.config.has_section(section):
      self.config.add_section(section)
    self.config.set(section, param, value)
    self._write()

  def get(self, section, param):
    return self.config.get(section, param)
    
  def _write(self):
    with open('%s/dl.conf' % self.home, 'wb') as configfile:
        self.config.write(configfile)
      
      
class Task:
  def __init__(self, datalab, name, description):
    self.dl = datalab
    self.name = name  
    self.description = description
    self.logger = None
    self.params = []
    self.addOption("debug", Option("debug", "", "print debug log level messages", default = False))
    self.addOption("verbose", Option("verbose", "", "print verbose level log messages", default = False))
    self.addOption("warning", Option("warning", "", "print warning level log messages", default = False))
    
  def run(self):
    pass
    
  def addOption(self, name, option):
    self.params.append(name)
    setattr(self, name, option)

  def addLogger(self, logLevel, logFile):
    logFormat = ("%(asctime)s %(thread)d vos-"+str(version)+"%(module)s.%(funcName)s.%(lineno)d %(message)s")
    logging.basicConfig(level = logLevel, format = logFormat,
                        filename = os.path.abspath(logFile))
    self.logger = logging.getLogger()
    self.logger.setLevel(logLevel)
    self.logger.addHandler(logging.StreamHandler())

  def setLogger(self, logLevel = None):
    if logLevel is None:
      logLevel = logging.ERROR
      if self.verbose: logLevel = logging.INFO
      if self.debug: logLevel = logging.DEBUG
      if self.warning: logLevel = logging.WARNING
    else:
      logLevel = logLevel
    self.addLogger(logLevel, "/tmp/datalab.err")

  def setOption(self, name, value):
    if hasattr(self, name):
      opt = getattr(self, name)
      opt.value = value
    else:
      print "Task '%s' has no option '%s'" % (self.name, name)
      

class Login(Task):
  def __init__(self, datalab):
    Task.__init__(self, datalab, 'login', 'login to the DataLab')
    self.addOption("user", Option("user", "", "username of account in DataLab", required = True))
    self.addOption("password", Option("password", "", "password for account in DataLab", required = True))
    self.addOption("mount", Option("mount", "", "mountpoint of remove VOSpace"))
    self.status = dl.get("login", "status")           

  def run(self):
    # Check if user already logged in
    if self.status == "loggedin":
      print "User '%s' is already logged in to the DataLab" % self.user.value
      return
    else:
      self.dl.save("login", "status", "loggedin")
    # Log a user into the DataLab
    print "Welcome to the DataLab, %s" % self.user.value
    # Default parameters if mount requested
    if self.mount.value != "":
      print "Initializing mount"
      mount = Mountvofs()
      mount.setOption('vospace', 'vos:')
      mount.setOption('mount', self.mount.value)
      mount.setOption('cache_dir', None)
      mount.setOption('cache_limit', 50 * 2 ** (10 + 10 + 10))
      mount.setOption('cache_nodes', False)
      mount.setOption('max_flush_threads', 10)
      mount.setOption('secure_get', False)
      mount.setOption('allow_other', False)
      mount.setOption('foreground', False)
      mount.run()


class Logout(Task):
  def __init__(self, datalab):
    Task.__init__(self, datalab, 'login', 'login to the DataLab')
    self.addOption("unmount", Option("unmount", "", "mountpoint of remove VOSpace"))
    self.status = self.dl.get("login", "status")           

  def run(self):
    if self.status == 'loggedout':
      print "No user is currently logged into the DataLab"
      return
    else:
      self.dl.save("login", "status", "loggedout")
      print "You are now logged out of the DataLab"
    if self.unmount.value != "":
      cmd = "umount %s" % self.unmount.value
      subprocess.Popen(cmd, shell = True, stdout = PIPE)
      output = pipe.stdout.read()
      

class Addcapability(Task):
  def __init__(self, datalab):
    Task.__init__(self, datalab, 'addcapability', 'activate a capability on a VOSpace container')
    self.addOption("fmt", Option("fmt", "", "the formats to accept", required = True))
    self.addOption("dir", Option("dir", "", "container name", required = True))
    self.addOption("cap", Option("cap", "", "capability name", required = True))
    
  def run(self):
    # Add a capability to a VOSpace container
    mountpoint = self.dl.get('vospace', 'mount')
    if mountpoint is None:
      print("No mounted VOSpace can be found")
    else:
      shutil.copy("caps/%s_cap.conf" % self.cap.value, "%s/%s" % (mountpoint, self.dir.value))


class Query(Task):
  def __init__(self, datalab):
    Task.__init__(self, datalab, 'query', 'query a remote db in the DataLab')
    self.addOption("uri", Option("uri", "", "database URI", required = True))
    self.addOption("ofmt", Option("ofmt", "", "requested output format", required = True))
    self.addOption("out", Option("out", "", "output filename", required = True))
    self.addOption("sql", Option("sql", "", "input SQL filename", required = True))
                
  def run(self):
    # Send a query to the DataLab query service
    h = Http()
    url = urlparse(self.uri.value)
    if url.scheme != "dldb":
      print "The 'uri' parameter does not begin with the 'dldb' scheme"
    else:
      sql = open(self.sql.value).read()
      headers = {'Content-Type': 'text/ascii'} # application/x-sql
      parts = url.path[1:].strip().split("/")
      user = parts[0]
      if "dbs" in parts:
        source = "db"
      else:
        source = "/".join(parts[1:])    
      table = url.fragment
      format = self.ofmt.value
#      dburl = 'http://dldev1.tuc.noao.edu:7138/query?user=%s&source=%s&table=%s&fmt=%s' % (user, source, table, format)
      dburl = 'http://localhost:7138/query?user=%s&source=%s&table=%s&fmt=%s' % (user, source, table, format)
      resp, content = h.request(dburl, 'POST', body = sql, headers = headers)
      print dburl, resp, content
      file = open(self.out.value, 'wb')
      file.write(content)
      file.close()
      

class LaunchJob(Task):
  def __init__(self, datalab):
    Task.__init__(self, datalab, 'exec', 'launch a remote task in the DataLab')
    self.addOption("cmd", Option("cmd", "", "name of remote task to run", required = True))

  def run(self):
    # Execute a remote processing job in the DataLab
    pass


class Mountvofs(Task):
  def __init__(self, datalab):
    Task.__init__(self, datalab, 'mount', 'mount the default VOSpace')
    self.addOption("vospace", Option("vospace", "", "VOSpace to mount", required = True, default = "vos:"))
    self.addOption("mount", Option("mount", "", "mount point for VOSpace", required = True, default = "/tmp/vospace"))
    self.addOption("foreground", Option("foreground", "", "mount the filesystem as a foreground operation", default = False))
    self.addOption("cache_limit", Option("cache_limit", "", "upper limit on local diskspace to use for file caching (in MB)", default = 50 * 2 ** (10 + 10 + 10)))
    self.addOption("cache_dir", Option("cache_dir", "", "local directory to use for file caching", default = None))
    self.addOption("readonly", Option("readonly", "", "mount VOSpace readonly"))
    self.addOption("cache_nodes", Option("cache_nodes", "", "cache dataNode Properties"))
    self.addOption("allow_other", Option("allow_other", "", "allow all users access to this mountpoint"))
    self.addOption("max_flush_threads", Option("max_flush_threads", "", "upper limit on number of flush (upload) threads", default = 10))
    self.addOption("secure_get", Option("secure_get", "", "use HTTPS instead of HTTP"))

        
  def run(self):
    # Mount a VOSpace via FUSE
#    readonly = False
    conn = vos.Connection()
    root = self.vospace.value
    mount = os.path.abspath(self.mount.value)
    if self.cache_dir.value is None:
      self.cache_dir.value = os.path.normpath(os.path.join(
            os.getenv('HOME', '.'), root.replace(":", "_")))
    if not os.access(mount, os.F_OK): os.makedirs(mount)
    if platform == "darwin":
      fuse = FUSE(VOFS(root, self.cache_dir.value, self.readonly.value,
                        conn=conn, cache_limit=self.cache_limit.value,
                        cache_nodes=self.cache_nodes.value,
                        cache_max_flush_threads=self.max_flush_threads.value,
                        secure_get=self.secure_get.value),
                    mount,
                    fsname=root,
                    volname=root,
                    defer_permissions=True,
                    daemon_timeout=DAEMON_TIMEOUT,
                    readonly=readonly,
                    # auto_cache=True,
                    allow_other=self.allow_other.value,
                    noapplexattr=True,
                    noappledouble=True,
                    foreground=self.foreground.value)
    else:
      fuse = FUSE(VOFS(root, self.cache_dir.value, self.readonly.value,
                        conn=conn, cache_limit=self.cache_limit.value,
                        cache_nodes=self.cache_nodes.value,
                        cache_max_flush_threads=self.max_flush_threads.value,
                        secure_get=self.secure_get.value),
                    mount,
                    fsname=root,
                    readonly=readonly,
                    allow_other=self.allow_other.value,
                    # auto_cache=True,
                    foreground=self.foreground.value)
    self.dl.save('vospace', 'mount', mount)


def parseArgs(task, args):
  # Parse task parameters  
  params = []
  if "--help" in args:
    print "The '%s' task takes the following parameters:" % task.name
    for par in task.params:
      if getattr(task, par).required:
        print "  %s - %s [required]" % (par, getattr(task, par).description)
      else:
        print "  %s - %s [optional]" % (par, getattr(task, par).description)
    sys.exit()
  else:
    # Set task parameters
    for i in range(2, len(args)):
      parts = args[i].strip().split("=")
      name = parts[0][0] == "-" and parts[0][2:] or parts[0]
      params.append(name)
      if hasattr(task, name):
        opt = getattr(task, name)
        opt.value = parts[1]
      else:
        print "The parameter '%s' is not supported by this task" % name
        sys.exit(-1)
    # Set logging
    task.setLogger()
    # Check that required parameters are not missing
    for par in task.params:
      if getattr(task, par).required and par not in params:
        print "The parameter '%s' is not set but is required by this task" % par
        sys.exit(-1)

      
if __name__ == "__main__":

  # initialize datalab
  dl = DataLab()

  # supported tasks
  tasks = {'login': Login,
           'logout': Logout,
           'mount': Mountvofs,
           'addcapability': Addcapability,
           'query': Query,
           'exec': LaunchJob}
    
  # list tasks
  if sys.argv[1] == 'help':
    print "Syntax: datalab [task] where [task] is one of:"
    for task in tasks:
      print '%s - %s' % (task, tasks[task][1])
  # parse arguments
  elif sys.argv[1] in tasks:
    task = tasks[sys.argv[1]](dl)
    opt = parseArgs(task, sys.argv)
    task.run()
  else:
    print "The task '%s' is not supported by the datalab command" % sys.argv[1]
  sys.exit()


